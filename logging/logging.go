// Package logging provides an abstraction over standard logger implementation.
// It has leveled logger implementation and an easier to use APIs in compare to standard logger.
package logging

import (
	"fmt"
	"log"
	"os"
)

// level is the log level type.
type level int

// Different log levels defined as level type.
const (
	TRACE level = iota
	DEBUG
	INFO
	WARN
	ERROR
)

// String representation of log level that is used as prefix in log messages.
func (l level) String() string {
	return [5]string{"[ TRACE ] ", "[ DEBUG ] ", "[ INFO  ] ", "[ WARN  ] ", "[ ERROR ] "}[l]
}

// flags define which text to prefix to each log entry generated by the logger.
// For more information see constants defined in standard log package.
const flags = log.LstdFlags | log.Lmicroseconds | log.Lshortfile

// Logger is the main abstraction with support for leveled logging.
// All log methods have message and values as parameters and so are used in formatted style representation;
// like in fmt package functions.
type Logger struct {
	level       level
	traceLogger *log.Logger
	debugLogger *log.Logger
	infoLogger  *log.Logger
	warnLogger  *log.Logger
	errorLogger *log.Logger
}

// NewLogger creates a new logger with level defined as argument.
func NewLogger(level level) *Logger {
	return &Logger{
		level:       level,
		traceLogger: log.New(os.Stderr, TRACE.String(), flags),
		debugLogger: log.New(os.Stderr, DEBUG.String(), flags),
		infoLogger:  log.New(os.Stderr, INFO.String(), flags),
		warnLogger:  log.New(os.Stderr, WARN.String(), flags),
		errorLogger: log.New(os.Stderr, ERROR.String(), flags),
	}
}

// NewLoggerFrom creates a new logger with level defined as specifier.
// For example info specifier creates INFO level logger, or warning creates WARN level logger.
// If specifier will not match any log level, INFO will be selected as default log level.
func NewLoggerFrom(specifier string) *Logger {
	return &Logger{
		level:       asLevel(specifier),
		traceLogger: log.New(os.Stderr, TRACE.String(), flags),
		debugLogger: log.New(os.Stderr, DEBUG.String(), flags),
		infoLogger:  log.New(os.Stderr, INFO.String(), flags),
		warnLogger:  log.New(os.Stderr, WARN.String(), flags),
		errorLogger: log.New(os.Stderr, ERROR.String(), flags),
	}
}

// Trace logs a trace message if log level is equal to TRACE.
func (l *Logger) Trace(message string, values ...interface{}) {
	if l.level == TRACE {
		_ = l.traceLogger.Output(2, fmt.Sprintf(message, values...))
	}
}

// Debug logs a debug message if log level is less than or equal to DEBUG.
func (l *Logger) Debug(message string, values ...interface{}) {
	if l.level <= DEBUG {
		_ = l.debugLogger.Output(2, fmt.Sprintf(message, values...))
	}
}

// Info logs an info message if log level is less than or equal to INFO.
func (l *Logger) Info(message string, values ...interface{}) {
	if l.level <= INFO {
		_ = l.infoLogger.Output(2, fmt.Sprintf(message, values...))
	}
}

// Warn logs a warning message if log level is less than or equal to WARN.
func (l *Logger) Warn(message string, values ...interface{}) {
	if l.level <= WARN {
		_ = l.warnLogger.Output(2, fmt.Sprintf(message, values...))
	}
}

// Error logs an error message if log level is less than or equal to ERROR.
func (l *Logger) Error(message string, values ...interface{}) {
	if l.level <= ERROR {
		_ = l.errorLogger.Output(2, fmt.Sprintf(message, values...))
	}
}

// Fatal logs an error message with an additional call to os.Exit(1).
func (l *Logger) Fatal(message string, values ...interface{}) {
	_ = l.errorLogger.Output(2, fmt.Sprintf(message, values...))
	os.Exit(1)
}

// asLevel converts a specifier to an appropriate log level; in case of no match found returns INFO as log level.
func asLevel(specifier string) level {
	switch specifier {
	case "TRACE", "trace":
		return TRACE
	case "DEBUG", "debug":
		return DEBUG
	case "INFO", "info":
		return INFO
	case "WARNING", "WARN", "warning", "warn":
		return WARN
	case "ERROR", "error":
		return ERROR
	default:
		return INFO
	}
}
